1. 单例模式和工厂模式

> 工厂模式一般就是单例 
>
> 如ApplicationContext

2. 策略模式和工厂模式

> 策略模式属于行为型模式 工厂模式属于创建型模式
>
> 策略模式关注封装后逻辑的使用
>
> 工厂模式关注点是封装创建逻辑

3. 策略模式和委派模式

> 策略模式关注是否可以互相替代
>
> 委派模式关注逻辑、任务的分发，如果分发的逻辑可以互相替换，那就可以用策略模式来实现委派。

4. 工厂方法模式和模板方法模式

> 工厂方法模强调创建，模板方法强调内部逻辑固定。

5. 模板方法和策略模式

> 模板方法不能改变算法流程，策略不是可以改变流程且可替换。
>
> 模板方法是针对定义一个算法的流程，将细微差异交给子类实现。策略模式单个策略内部算法是封闭的。

6.装饰者模式和静态代理模式

> 装饰者模式关注给对象扩展与添加方法。代理关注控制对象的访问及对象的增强。
>
> 装饰者模式一般将被装饰对象作为构造器参数，静态代理模式持有被代理对象的引用

7.装饰者模式和适配器模式

> 都是包装器模式wrapper
>
> 装饰器模式 装饰者与被装饰者一般是实现同一个接口或继承关系。
>
> 适配器模式 适配器与被适配者可以实现不同的接口

8.适配器模式和静态代理模式

> 适配器可以使用静态代理来实现适配，适配器持有被适配对象的引用来实现新的接口。

| 模式名称   | 一句话描述                     |
| ---------- | ------------------------------ |
| 单例模式   | 最多有且仅有一个               |
| 工厂模式   | 不关心内部实现，直接获取       |
| 原型模式   | 克隆复制                       |
| 代理模式   | 职责转移，你的活我来干         |
| 委派模式   | 职责分发，我接活发给下面的人干 |
| 策略模式   | 封装好的可替换算法             |
| 模板模式   | 跟着流程走                     |
| 适配器模式 | 实现不同功能的兼容             |
| 装饰者模式 | 锦上添花                       |
| 观察者模式 | 打声招呼，有事儿叫我           |